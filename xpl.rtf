{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red26\green26\blue26;
\red246\green247\blue249;}
{\*\expandedcolortbl;;\csgenericrgb\c0\c0\c0;\csgenericrgb\c100000\c100000\c100000;\cssrgb\c13333\c13333\c13333;
\cssrgb\c97255\c97647\c98039;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
{\info
{\author Daniel Weaver}}\margl1440\margr1440\vieww11880\viewh18700\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ri0\pardirnatural\qc\partightenfactor0

\f0\fs24 \cf0 \
XPL to C Source Language Translator\
Daniel Weaver\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf0 \
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 1.		Introduction\cf2 \cb3 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 \
	      \CocoaLigature0 XPL is a dialect of PL/I created by W. M. McKeeman et. al. and described in his book \ul A Compiler Generator\ulnone .  XPL was designed to be used in table-driven syntax-directed translators such as the XPL compiler itself.  The XPL system, which includes the compiler, SKELETON, and ANALYZER, provides a quick and efficient method for defining a language.  If a BNF (BACKUS-NAUR FORM) description of a computer language is input to the ANALYZER, it generates the syntax tables used in either SKELETON or the XPL compiler.  The syntax tables along with SKELETON form a syntax checker for your BNF grammar. Code emitters may be added to upgrade the syntax checker to a compiler.\
\
1.1	Source Translation\
\
	       This implementation of the XPL compiler is an XPL to C source language translator.  The compiler translates XPL source to C source which can be compiled on any computer that supports a C compiler.  Unlike most XPL compilers, this compiler is not a self compiling compiler.  It is written in C and there is no plan to rewrite it in XPL.  The runtime is also written in C.  This allows anyone with a C compiler to compile code written in XPL.  Using C as a target language does cause some limitations on the compiler.  These are listed in the section on 
\i Limitations
\i0 .\
\
1.2	Language features\
\
	       The XPL language includes structured program flow, powerful character string manipulators, and fixed and logical operations.  Character strings may be from 0 to 2,147,483,647 bytes long. Fixed point operation may be done on 8, 16, 32 or 64 bit quantities.  64 bit integers are supported only if supported by the target C compiler and the underlying hardware.\
\
1.3	Installation\
\
	      It is my hope that the XPL compiler will run straight out of the box but you still may need to tweak it to get BIT(64) integers to work.  Look at the file xpl.h and check the definitions for XPL_LONG, XPL_UNSIGNED_LONG and XPL_ADDRESS.  If your compiler does not support the C99 (or later) standard then you may need to tweak these typedefs to get BIT(64) to work properly.\
	    This compiler works best when run on a C compiler that supports C99 (or later) standard.\
\
2.0	Constants, Identifiers and Comments\
\
2.1	Identifiers\
\
	      An identifier is an alphabetic (A thru Z, a thru z, #, $, @, and _) optionally followed by any number of alphabetics or numbers (0 thru 9).  The first 256 characters of the identifier must be unique.  Generally speaking, the compiler loves long names, but identifiers longer than 23 characters will smear the symbol table dump.  Keywords in XPL are reserved and may not be used as identifiers.  The following symbols are reserved in XPL:\

\b \
		bit		declare	external	initial		return		xor\
		by		do		fixed		label		then\
		call		else		go		literally	to\
		case		end		goto		mod		transparent\
		character	eof		if		procedure	while\

\b0 \
\
2.2	Character string constants\
\
	      String constants begin with a single quote and end with a single quote.  The single quote itself may be used with a string constant by using two single quotes in a row.  Examples of string constants:\
		'This is a string constant'\
		'Surely, you can''t be serious.'\
		'I''m very serious.  And stop calling me Shirley.'\
\
2.3	Integer constants\
		
\f1\b \
	<number> ::= <integer>\
	         | <bit string>\
	<integer> ::= <decimal digit>\
	          | <integer> <decimal digit>\
	<decimal digit> ::= 0|1|2|3|4|5|6|7|8|9\

\f0\b0 \
	      Integer constants are made up of the digits 0 thru 9.  Decimal numbers may not have embedded blanks.  Examples:\
		10	42	32768\
	Negative numbers are supported but they are actually expressions.\
\
2.4	Bit Strings\

\f1\b \
	<bit string> ::= " <bit list> "\
	<bit list> ::= <hex integer>\
	           | <bit group>\
	           | <bit list> <bit group>\
	<bit group> ::= (1) <binary integer>\
	            | (2) <quartal integer>\
	            | (3) <octal integer>\
	            | (4) <hex integer>\
	            | ( <bit width> ) <extended hexadecimal>\
	<binary integer> ::= <binary digit>\
	                 | <binary integer> <binary digit>\
	<binary digit> ::= 0|1\
	<quartal integer> ::= <quartal digit>\
	                  | <quartal integer> <quartal digit> \
	<quartal digit> ::= 0|1|2|3\
	<octal integer> ::= <octal digit>\
	                | <octal integer> <octal digit>\
	<octal digit> ::= 0|1|2|3|4|5|6|7\
	<hex integer> ::= <hex digit>\
	              | <hex integer> <hex digit>\
	<hex digit> ::= 0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f
\f0\b0 \
\
	      Binary, octal, and hexadecimal are supported and require the number to be enclosed in double quotes.  The number of bits in the radix can be explicitly changed by enclosing a small constant in parentheses.  The default radix is 16 so the default number of bits needed for each digit is 4.   The radix may be changed within a number by supplying a new width in parentheses.  Blanks may be used within bit strings.  Macros are not recognized within bit strings.  Examples:\
\
 		"(1) 1010 1100" 	 binary.\
		"(2) 2230"    	  quaternary.\
		"(3) 254"     	  octal.\
		"(4) AC"      	  hexadecimal.\
		"AC"          	  also hexadecimal.\
		"(1) 1 (2) 3 (3) 7 (4) F"  	 mixed (equal to "3ff").\
\
	      All character string and bit string constants are null terminated because of the underlying C compiler.  Dynamically created strings do not have a null terminator.\
\
2.5	Extended hexadecimal bit strings\

\f1\b \
 	<bit group> ::= ( <bit width> ) <extended hexadecimal>\
	<extended hexadecimal> ::= <hex digit>\
	                       | <extended hexadecimal> <hex digit>\
	<hex digit> ::= 0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f
\f0\b0 \
\
	      As an extension to the XPL language, this compiler allows the bit width to be any number between 1 and 64 (32 for a 32 bit machine).  This allows you to use values that are wider than 4 bits and aligned on arbitrary boundaries.  When using this feature a blank will terminate the bit field.\
	     Let\'92s say you have a 16 bit opcode where the most significant bit is a one bit field and the remainder of the opcode is three five bit fields.  For this example the left most bit is zero and all three five bit fields are set to one.  Using simple <bit string> and hexadecimal the value would be "0421".  It is possible to render the string with a mix of binary and hexadecimal "(1) 0 0 (4)1 (1)0 (4)1 (1)0 (4)1".  This is not very easy to read.  However if you use <extended hexadecimal>  the bit string becomes "(1)0 (5)01 01 01".  Which is much easier to read.\
	    Here is a real world example using the SPARC instruction set:\
		"(2)0 (5)1f (6)00 (5)1f (1)0 (13)fff"\
\
2.6	C character string emulation\
\
	      Another extension to the original XPL language allows the definition of strings that look similar to strings in C.  This feature is activated by using the letter C instead of a number surrounded by parentheses.  A C string would be "(c)Hello World!".  This string format recognizes the C escape characters when used in conjunction with the backslash.  The following escape characters are supported:\
		\\a	Bell\
		\\b	Backspace\
		\\f	Formfeed\
		\\n	Newline\
		\\r	Carriage Return\
		\\t	Tab\
		\\v	Vertical Tab\
		\\\\	Blackslash\
		\\'	Single Quote\
		\\"	Double quote\
		\\?	Question mark\
		\\xHH	Hex byte\
		\\777	Octal\
\
	    This feature is very useful when used with the 
\b xprintf
\b0  function.  Example:\
		
\b do k = 1 to 10;\
			call xprintf("(c)The value of k is %d\\n", k);\
		end;
\b0 \
\
2.7	Type conversion done by 
\fs24\fsmilli12370 \cf4 \cb5 \expnd0\expndtw0\kerning0
\CocoaLigature1 Schr\'f6dinger's cat\
\

\fs24 \cf2 \cb3 \kerning1\expnd0\expndtw0 \CocoaLigature0 	      According to the original XPL definition bit strings longer than 32 bits are converted to 
\b character
\b0  type.  This had to be modified to allow for 64 bit hexadecimal numbers.\
	     Within the compiler bit strings less than 64 bits (32 on a 32 bit machine) are kept as both an integer and a character string.  The selection of which form to use is chosen by the context of the statement which uses the bit string.  The compiler chooses the type that requires the least amount of type conversion.  For example:\
		
\b declare string character, number bit(32);\
		string = "(c)HI";\
		number = "(c)HI";
\b0 \
	      Will set the variable 
\b string
\b0  to two bytes 'H' and 'I'.  The variable 
\b number
\b0  will be set to 18505.\
\
2.8	Comments\
\
	      The XPL compiler has two types of comments.  It supports the // comment as well as the /* */ style comment of PL/I.  Comments that start with a // extend to the end of the line and may be placed anywhere on the line.  Comments that start with a slash asterisk(/*) extend to the next asterisk slash (*/).  Comments may span record boundaries and contain any character.  Comments may appear anywhere a blank may appear except within bit strings.  Generally comments do not affect the execution of the program and should be used freely to document the text.  Example:\
		/* THIS IS A COMMENT */\
	      PL/I style comments may contain control toggles that may have some effect on your program.  Control toggles are characters proceeded by a dollar sign ($).  The toggles are turned on or off by a dollar sign followed by the character(e.g. $S).  Control toggles may also be set on the command line when the compiler is invoked.  Most control toggles are upper case letters.\
	      The control toggles may be pushed or popped using $>
\b <letter>
\b0  or $<
\b <letter>
\b0  respectively.   Example:\
		/* Push the value of H.  $>H  After a push the toggle is OFF */\
		
\b declare new_variable fixed;
\b0 \
		/* Pop the value of H. $<H  The toggle returns to its previous value. */\
\
3.	Declarations and Data Types\
\
3.1	Data Types\

\f1\b \
	<type> ::= fixed\
	       | character\
	       | label\
	       | <bit head> <expression> )\
	       | <character head> <expression> )\
	<bit head> ::= bit (\
	<character head> ::= character (
\f0\b0 \
\
	      The XPL compiler supports 8 data types that may be used for data storage or arithmetic expressions.  Identifiers declared as BIT(1) are assumed to be boolean values that hold only the value of 0 or 1.  They are allocated as 
\i char
\i0  and may be used in arithmetic expressions.  Identifiers declared as BIT(2) thru BIT(8) are allocated as 
\i unsigned char
\i0  and may hold the values of 0 thru 255.  Identifiers declared as BIT(9) thru BIT(16) will be allocated as 
\i signed short 
\i0 and will be treated as signed 16 bit integers in arithmetic expressions.  Identifiers declared as BIT(17) thru BIT(32) or FIXED will be allocated as 
\i signed int
\i0  and will be treated as signed 32 bit integers in arithmetic expressions.  When supported by the hardware BIT(33) thru BIT(64) will be allocated as 
\i signed long
\i0  and treated as 64 bit signed integers.  CHARACTER declarations, and BIT declarations larger than 32, (or 64 on 64-bit machines) are considered strings.  Strings are not permitted in arithmetic expressions with the exception that you may compare one string to another.  Each string has an eight, or twelve, byte string descriptor.  This descriptor contains the byte address of the text of the string and four bytes for the string's length.\
	      Using a BIT width larger that 64 is identical to using dynamic CHARACTER strings.  The number of bits in the declaration does not limit the length of the string since these strings are allocated in the string FREESPACE.  In the following example the bit string is length 5 regardless of how many bits were stated in the DECLARE statement.\
		
\b declare stuff bit(4096) initial('12345');
\b0 	/* The length(stuff) is 5 */\
		
\b stuff = 'A longer string.';
\b0 			/* The length(stuff) is now 16 */\
	      The fixed length CHARACTER format e.g. CHARACTER(5) is used much like dynamic character strings except that it allocates a dedicated storage area to hold the string.  All fixed length strings are null terminated.  When the string is used as a source the compiler creates a descriptor that holds the address and length of the string.  The descriptor format is exactly like the descriptors used for variable length strings.  The length of the string is created by finding the null terminator.  When a fixed length string is used in a store operation the data in the string is copied to the storage area of the fixed length string and a null terminator is attached to the end of the string.  If the string is longer than the space allotted to the fixed length string the string will be truncated and the null terminator will be placed in the last byte of the string.  Fixed length strings are designed to help interface to programs written in C.\
	      The LABEL declaration type is used for GOTO's and forward procedure calls.\
\
3.2	Address type\
\
	      The XPL compiler defines a macro that describes an address type.  On machines that have a 32-bit address the macro will be:\
		
\b declare address literally 'bit(32)';
\b0 \
	On machines that have a 64-bit address the macro will be:\
		
\b declare address literally 'bit(64)';
\b0 \
	 The identifier 
\i address
\i0  is not a reserved word.\
\
3.3	Declarations\

\f1\b \
	<declaration statement> ::= declare <declaration element>\
	          | <declaration statement> , <declaration element>\
	<declaration element> ::= <type declaration>\
	                      | <identifier> literally <string>\
	<type declaration> ::= <identifier specification> <type>\
	                   | <bound head> <expression> ) <type>\
	                   | <type declaration> <initial list>\
	<identifier specification> ::= <identifier>\
	                   | <identifier list> <identifier> )\
	<identifier list> ::= (\
	                  | <identifier list> <identifier> ,\

\f0\b0 \
	      If you're gonna use XPL you gotta DECLARE all your variables.  The DECLARE statement associates identifiers with various attributes and allocates memory.  The following statement will declare I, J, and K to be 32 bit integers.\
		
\b declare i bit(32), j bit(32), k bit(32);
\b0 \
	      Data types may be factored as in the following example which also declares I, J, and K to be 32 bit integer.\
		
\b declare (i, j, k) bit(32);
\b0 \
	      Declaration statements may be grouped to add readability to the program, or you may group them because you dislike to type the word DECLARE over and over again.  The following statement shows a glob of declarations bunched together for aesthetic reasons.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2163\fi-2165\ri0\pardirnatural\partightenfactor0
\cf2 		
\b declare any_identifier bit(16), and_receive_a_free character, string bit(8);
\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 	      When you get tired of declaring scalar variables try arrays.  An array is a contiguous block of memory that is referenced by only one identifier followed by a subscript.  Arrays in XPL start at subscript zero, therefore when allocating arrays, use one less than the number of elements that you actually need.  FORTRAN programmers who think that starting an array reference at zero is inconvenient have three choices. 1) Throw the zeroth element away, 2) Go back to FORTRAN (we didn't want you any way) 3) Learn to count starting from zero.  The following example shows an array of HOPE.\
		
\b declare hope(255) bit(16);
\b0 \
	      Factoring becomes more complicated with arrays.  You must factor both the number of elements and the type.  The following example declares three of the seven dwarves to be 32 bit integer arrays of 7 elements each.\
		
\b declare (dopey, grumpy, sneezy) (6) bit(32);
\b0 \
\
3.4	Initialization\

\f1\b \
	<initial list> ::= <initial head> <expression> )\
	<initial head> ::= initial (\
	               | <initial head> <expression> ,\

\f0\b0 \
	      All static variables are set to zero when the program starts execution unless explicitly initialized by the INITIAL clause of the DECLARE statement.  The INITIAL clause sets a value into the data when the program starts.  The INITIAL value may be a character string constant or an integer expression.\
	      The INITIAL clause may be used to initialize arrays.  When initializing arrays, the first value is stored into the first element of the array (index zero), the second value is placed into the second element and so on.  If the number of values is less than the number of elements in the array, the balance of the array is set to zero (or the null string if a CHARACTER array).  Example:\
		
\b declare size literally '34',\
		table(size) bit(16) initial(0, 1, 2, 3, 4, 5, 6, 7),\
		pt bit(16) initial(size + 1),\
		name character initial('Texas'),\
		message character(20) initial(' Read this first');
\b0 \
\
	     This is different from the INITIAL statement defined by the PL/I language.  XPL INITIAL statements allow expressions but do not allow repetition factors.\
\
3.5	Macro Definitions\
\
	      XPL provides a simple text substitution macro.  Each time the macro name occurs in the input text the compiler replaces the identifier name with the specified text. This feature is very useful for defining array bounds or abbreviations.  The following example shows its usefulness:\
		
\b declare proc literally 'procedure',\
			LIMIT literally '127',\
			z(LIMIT) bit(16);\
		sum: proc bit(16);\
			declare (i, n) bit(16);\
			n = 0;\
			do i = 0 to LIMIT;\
				n = n + z(i);\
			end;\
			return n;\
		end sum;\

\b0 	      Macros may also be nested, as in the example:\
		
\b declare TRUE literally '1';\
		declare forever literally 'while TRUE';\
		do forever;\
			output = 'Print this forever';\
		end;\

\b0 \
 	      In this implementation of the XPL language macros are stored in the symbol table.  Therefore they have scope.  Any macro declared in a procedure will be undefined when the procedure ends.  Macros defined in an outer scope can not be redefined when you enter a new procedure.  Use of the macro name in a DECLARE statement will be expanded before the DECLARE statement is processed.\
\
4.	Procedures\
\
4.1	Functions and Subroutines\

\f1\b \
	<basic statement> ::= <procedure definition> ;\
	
\fs22 <procedure definition> ::= <procedure statement> <statement list> <ending>
\fs24 \
	<procedure statement> ::= <procedure head> ;\
	                      | <procedure head> external\
	                      | <procedure head> transparent\
	<procedure head> ::= <procedure name>\
	                 | <procedure name> <type>\
	                 | <procedure name> <parameter list>\
	                 | <procedure name> <parameter list> <type>\
	<procedure name> ::= <label definition> procedure\
	<parameter list> ::= <parameter head> <identifier> )\
	<parameter head> ::= (\
	                 | <parameter head> <identifier> ,\
	<ending> ::= end\
	         | end <identifier>\
	         | <label definition> <ending>\
	<label definition> ::= <identifier> :
\f0\b0 \
\
	      The procedure is a clever device designed to facilitate the grouping of mutually confusing statements so that they may be ignored en mass.  Procedures that do not return a value are called subroutines.  Subroutines must be called with the CALL statement.  Procedures that return values are functions.  Functions may be referenced as variables or called with the CALL statement.  All procedures must be defined or declared before they are referenced.  The procedure is defined when the body of the procedure appears in the input text.  Procedures need not have any parameters but if any parameters are used they must be DECLAREd before they are referenced within the body of the procedure.  Below is an example of a valid subroutine definition:\
\
		
\b test:\
			procedure(a, b, c);\
				declare a bit(16), b fixed, c character;\
				/* put body of procedure here */\
				return;\
			end test;
\b0 \
\
	      Here is the above procedure done as a function:\
\
		
\b test:\
			procedure(a, b, c) bit(16);\
				declare a bit(16), b fixed, c character;\
				/* put body of procedure here */\
				return a + length(c);\
			end test;
\b0 \
\
	      All procedures in XPL use call by value.  Call by value moves the value of the calling statement's parameter into the procedure's local storage with type conversion (if necessary).  Call by value does not permit arrays to be passed as parameters.  When a call by value parameter is changed within the procedure the corresponding parameter in the calling statement is not changed.\
	      Procedures may be DECLAREd using the LABEL type to tell the compiler that the procedure is a forward call.  Example:\
\
		
\b declare test label;\
		call test(6);\
		/* other XPL statements */\
		test:\
			procedure(a);\
				declare a bit(16);\
				/* Add more statements here. */\
			end test;\

\b0 \
	      The number of parameters in the calling statement must match the number of parameters in the procedure.  Type conversion, if possible, will be performed as part of the calling sequence.\
\
4.2	External procedures\
\
	     XPL allows the declaration of external procedures similar to how external procedures are defined in PL/M.  Given a C function defined as:\
		
\b int my_function(short a, int b) \{\
			return a + b;\
		\}
\b0 \
	You can access this function from XPL with:\
		
\b my_function: procedure(a, b) fixed external;\
			declare a bit(16), b fixed;\
		end my_function;\
\
		result = my_function(6, 32768);
\b0 \
\
	      The EXTERNAL keyword may also be used to define forward referenced procedures.\
\
4.3	Transparent procedure definitions\
\
	     When you include a C header file with the 
\b inline
\b0  function the function prototypes defined in the header file should be used rather than a function prototype created by the XPL compiler.  The transparent keyword tells the compiler to enter the function into the symbol table but don\'92t generate any code to define the function in the output file.\
\
		
\b call inline('#include <stdio.h>');\
\
		putchar: procedure(char) fixed transparent;\
			declare char fixed;\
		end putchar;\
\
		call putchar(byte('?'));  /* Output the character '?' */
\b0 \
\
4.4	Scope\
\
	      Identifiers may only be referenced within their proper scope.  The scope of an identifier declared before any procedure definition, is any statement following the declaration.  Identifiers declared within procedures may only be referenced within the procedure they were declared in.  After each procedure ends, all variables defined in the procedure are removed from the symbol table.  Variables promoted to Global Scope will retain their value but all other variables will be undefined on subsequent calls to the procedure.  Procedures also permit the redeclaration of variables.  The compiler searches the most recent procedure first, then any other nested procedures, then global references, then built-in functions.\
	      This XPL compiler implements nested functions without support for nested functions in the target C compiler.  In order to do this most of the variables in the outer function have to be promoted to global scope.  This changes where the variables are allocated.  Normally they would be allocated on the stack but a nested function will cause them to be static in the generated C code.  The XPL compiler will display a list of variables that have been promoted to global scope when using the $D option to dump internal tables at the end of compilation.\
\
4.5	Call and Return\

\f1\b \
	<return statement> ::= return\
	                   | return <expression>\
	<call statement> ::= call <variable>\

\f0\b0 \
	      Procedures may be invoked by the CALL statement.  When a function is invoked by the CALL statement the value returned by the function is discarded.  Functions may also be referenced as variables within expressions.  Example: \
\
		
\b call scan(text);\
		token = scan(text);\

\b0 \
	      Due to the constraints of the underlying C compiler all functions must use the RETURN statement with a value.  All subroutines may only use RETURN statements without a value.  If execution of a procedure hits the END statement or a procedure, a return is executed with no value.\
	     If the RETURN statement is used outside of a procedure it will end the program.  The 
\b <expression>
\b0  on the RETURN statement will be the exit code of the program.\
 \
4.6	Recursive procedures\
\
	      XPL does not support recursion.  Just because the compiler target is a recursive language does not make the resulting code recursive.  Nested procedures cause local variables to be declared static.  In order to do garbage collection all character strings are allocated in a single array.  Character strings cannot be allocated on the stack.  This prevents subroutines and functions from being recursive.\
\
4.7	What happened to the main procedure?\
\
	     XPL does not use a main procedure like PL/I or C.  Statements that are not enclosed within a PROCEDURE are assumed to be the start of execution.  These statements appear as though they were enclosed in a PL/I procedure with 
\b procedure options(main)
\b0 .  
\b main
\b0  is not a reserved word in XPL.  This is a simple XPL program that calls a subroutine which happens to be named 
\b main
\b0 .\
\
		
\b /* The <identifier> main has no special meaning in XPL */\
		main: procedure;\
			output = 'Calling main procedure.';\
		end main;\
\
		/* The real main procedure starts here */\
		call main;\
		eof;
\b0 \
\
4.8	Calling XPL from some other language\
\
	     An XPL program may be called from a program written in some other language.  This is signaled to the compiler by using the 
\b -m
\b0  option on the command line.  Normally the compiler generates a 
\b main()
\b0  procedure which does some initialization then calls 
\b __xpl_user_main()
\b0  which is the XPL equivalent of the 
\b main
\b0  program in C.  If you want to call an XPL function from some other language you will need to do the initialization normally done in the C 
\b main()
\b0  program.  Example:\
\
		
\b /* This is XPL code compiled with the -m option */\
		xpl_code: procedure;\
			/* Do some super cool XPL stuff here */\
			output = 'Doing cool XPL stuff.';\
		end xpl_code;\
		eof eof eof
\b0 \
\
	Sample C code that calls XPL.\
\
		
\b #include "xpl.h"\
\
		void xpl_code(void);\
\
		int main(int argc, char **argv) \{\
			/* Initialize the XPL run time.  Only do this once. */\
			if (__xpl_runtime_init(0)) return 1;\
			__xpl_init_strings();\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2875\fi-2877\ri0\pardirnatural\partightenfactor0
\cf2 			/* Call any XPL function or procedure with the name used in the XPL code. */\
			xpl_code();\
			/* Be careful when naming the XPL functions.  Choose an <identifier> that is legal in both languages.  i.e. Don\'92t	define a function like build#value. */\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 			return 0;\
 		\}
\b0 \
\
	Multiple functions may be called from the foreign code but all the procedures must be placed in the same XPL file.\
\
5.	Control Flow\
\
5.1	IF THEN ELSE\

\f1\b \
 	<if statement> ::= <if clause> <statement>\
	               | <if clause> <true part> <statement>\
	               | <label definition> <if statement>\
	<if clause> ::= if <expression> then\
	<true part> ::= <basic statement> else\

\f0\b0 \
	      IF statements provide the programmer with a method to conditionally execute statements.  The statement following the THEN will be executed if the expression is true.  The ELSE statement will be executed, if one exists, if the expression is false.  If the expression is a logical variable or an integer the low order bit is tested to determine true or false.  Integers are true if the low order bit is one and false if the low order bit is zero.  Character strings may not be used as logical variables.  It is illegal to have two ELSE statements in a row.  This handicap may be circumvented by nesting the inner most IF/THEN/ELSE in a DO/END group.\
\
		
\b i = 1;\
		if i then output = 'Always print this';\
		else output = 'never print this';\
		if i > 10 then do;\
			if j = k then m = 77;\
			else m = 66;\
		end;\
		else m = 44;
\b0 \
\
	      Character strings are compared first on length then on the characters in the string.  This is usually not what you want.  The following procedure will compare strings byte by byte until the end of the shortest string, then length.\
\
		
\b string_gt:\
		procedure(l, r) bit(1);\
			/* return true if l > r */\
			declare (l, r) character,\
				(lenl, lenr) bit(32);\
			lenl = length(l);\
			lenr = length(r);\
			if lenl <= lenr then return l > substr(r, 0, lenl);\
			else return substr(l, 0, lenr) >= r;\
		end string_gt;\
		/* The following will reference the function */\
		if string_gt(a, b) then /* do something */\

\b0 \
5.2	DO CASE\

\f1\b \
 	<group> ::= <group head> <ending>\
	<group head> ::= do <case selector> ;\
	             | <group head> <statement>\
	<case selector> ::= case <expression>\

\f0\b0 \
	      The DO CASE statement uses the expression to select the Nth statement within the body of the DO group.  After the statement is executed control is returned to the CASE's END statement.  Statements are numbered from zero starting from the first statement after the DO CASE.  If the expression is negative or larger than the number of statements in the DO CASE, a random jump will be executed (Crash City).  Below is an example of a valid CASE statement:\
\
		
\b declare i bit(16);\
		i = 1;\
		do case i;\
			output = 'never print this';\
			output = 'always print this';\
			output = 'don''t print this';\
		end;\
		output = 'This is executed next';
\b0 \
\
\
5.3	DO WHILE\

\f1\b \
 	<group> ::= <group head> <ending>\
	<group head> ::= do <while clause> ;\
	             | <group head> <statement>\
	<while clause> ::= while <expression>\

\f0\b0 \
	      The DO WHILE statement will loop until the expression becomes false.  The expression is evaluated before the loop is entered.  If the expression is false the body of the DO WHILE is never executed.  Integers are true if the low order bit is one and false if the low order bit is zero.  If the expression is false control is passed to the statement after the END statement.  Below is an example of a valid DO WHILE statement. \
\
		
\b declare i bit(16);\
		i = 0;\
		do while i < 4;\
			i = i + 1;\
			output = 'testing ' || i;\
		end;\
		/* the above loop will be executed 4 times */\

\b0 \
\
5.4	DO Loops\

\f1\b \
 	<group> ::= <group head> <ending>\
	<group head> ::= do <step definition> ;\
	             | <group head> <statement>\
	
\fs22 <step definition> ::= <variable> <replace> <expression> <iteration control>
\fs24 \
	<iteration control> ::= to <expression>\
	                    | to <expression> by <expression>
\f0\b0 \
\
	        I had a friend who went to England and while he was in a Pub he overheard two guys talking about the origin of the DO loop.  One of the guys in the Pub said that the DO loop was invented by a file clerk who worked for a computer company at Hursley Laboratory in the UK.  The programmers in this computer company spent much of their time in committee designing large compiler projects.  The statements made in each meeting had to be numbered, filed and sent back to committee for review.  The file clerk, whose name is David Owens, was given the task of filing the results of the meetings.  David initialed each report before sending it back to the committee.  The committee came to refer to the iterative processing of statements as the David Owens loop, or DO loop for short.\
	      The DO loop provides iterative execution of a group of statements a certain number of times.  The DO loop provides a start value, an end value and an optional increment.  When the DO loop begins it sets the iteration variable to the start value.  If the iteration variable exceeds the end value then the body of the DO loop is never executed.  Otherwise the statements within the DO loop are executed.  After executing the statements in the loop, the variable is incremented by the expression in the BY clause of the DO statement.  Then the whole process repeats.  If the BY clause is omitted an increment of one is used.  Negative constants are permitted in the DO loop BY clause but all non-constant expressions are assumed to be positive.  The DO loop variable may not be indexed.  The escape value and loop increment can not be changed from within the DO loop, but the DO loop variable may be modified by the statements within the loop.  Here are some examples:\
\
		
\b declare c character, k fixed;\
		c = 'testing ';\
		do k = 1 to 3;\
			c = c || k || ' ';\
		end;\
		/* At this point c = 'testing 1 2 3 ' */\
		declare x, y, z;\
		y = 10;\
		z = 20;\
		do x = y to z by 2;\
			call it;\
			y, z = 4;\
		end;\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2147\fi-2149\ri0\pardirnatural\partightenfactor0
\cf2 		/* The above loop is executed 6 times x=10 x=12 x=14 x=16 x=18 x=20 */
\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 \
5.5	GO TO\

\f1\b \
 		<basic statement> ::= <go to statement> ;\
		<go to statement> ::= <go to> <identifier>\
		<go to> ::= go to\
		        | goto\

\f0\b0 \
	      The GOTO statement should be used only under extreme conditions, such as "My computer is on fire."  Indiscriminate use of the GOTO will brand you forever as an unstructured programmer and cause you to be deleted from my Christmas card list.  In the off chance that your computer is on fire, the following rules must be observed;  The label must be DECLAREd if it is to be used as an argument to the ADDR function before it is referenced.  The label must be DECLAREd if referenced within a procedure before it is defined and that same identifier is declared outside of the procedure.  GOTO statements may not jump into or out of a procedure.  Indexes are not permitted on GOTO statements.\
\
6.	Expressions\

\f1\b \
 	<expression> ::= <logical factor>\
	             | <expression> | <logical factor>\
	             | <expression> xor <logical factor>\
	<logical factor> ::= <logical secondary>\
	                 | <logical factor> & <logical secondary>\
	<logical secondary> ::= <logical primary>\
	                    | ~ <logical primary>\
	<logical primary> ::= <string expression>\
	       | <string expression> <relation> <string expression>\
	<relation> ::= =\
	           | <\
	           | >\
	           | ~ =\
	           | ~ <\
	           | ~ >\
	           | < =\
	           | > =\
	<string expression> ::= <arithmetic expression>\
	      | ::= <string expression> || <arithmetic expression>\
	<arithmetic expression> ::= <term>\
	                        | <arithmetic expression> + <term>\
	                        | <arithmetic expression> - <term>\
	                        | + <term>\
	                        | - <term>\
	<term> ::= <primary>\
	       | * <primary>\
	       | / <primary>\
	       | mod <primary>
\f0\b0 \
\
	     The caret (^) may be used instead of a tilde (~).\
\
6.1	Operator Precedence\
\
	      Operator precedence is formally defined by the BNF description of the language.  For those of you who can\'92t be bothered, here is the same information in table form. \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2877\fi-2879\ri0\pardirnatural\partightenfactor0
\cf2 		* 	1  Multiply.\
		/ 	1  Divide.\
		MOD 	1  Modulo.		The result may be positive or negative.\
		+ 	2  Add.\
		+ 	2  Unary add  (does nothing).\
		- 	2  Subtract.\
		- 	2  Unary subtract.\
		|| 	3  String concatenate.  If the operands are not character strings they will be converted to character strings. The operation will probably result in the movement of one or both of the operands in memory.\
		= 	4  Equal.\
		~ = 	4  Not equal.\
		> 	4  Greater than.\
		< 	4  Less than.\
		> = 	4  Greater than or equal to.\
		~ < 	4  Not less than.  Same as greater than or equal to.\
		< = 	4  Less than or equal to.\
		~ > 	4  Not greater than.  Same as less than or equal to.\
		~ 	5  Logical not.  Note that this is not the priority you normally expect logical not.  Normally it should be at priority 2.  This may cause confusion when used with compare operators.\
		& 	6  Logical AND.\
		| 	7  Logical OR.\
		XOR 	7  Exclusive OR.\
 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 	      Operators at the same priority will be evaluated left to right.\
\
6.2	Type Conversion\
\
	      Expressions are evaluated as BIT(8), BIT(16), BIT(32), and BIT(64).  Before any arithmetic operation is done the two operands must be of the same type.  The smaller precision operand will be converted automatically to the larger precision.  Conversion to CHARACTER will be done only when using the concatenate operator, the assignment statement, or certain built-in functions.  Fixed length character strings have the same rules as variable length character strings. \
	      Internally the compiler represents all integer constants as the largest precision supported by the C compiler, BIT(32) or BIT(64).\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li3594\fi-3596\ri0\pardirnatural\partightenfactor0
\cf2 	Condition -> Integer		If TRUE then 1, else 0.\
	Bit(8) -> Condition		If ZERO then FALSE, else TRUE.\
	BIT(8 thru 64) -> Condition If the least significant bit is set then TRUE, else FALSE\
	Integer -> CHARACTER	The integer is converted to a signed decimal character string.\
	CHARACTER -> Integer	Illegal\
	CHARACTER -> CHARACTER(<number>) The string is copied and a null terminator is added.\
	CHARACTER(<number>) -> CHARACTER A descriptor is created.  The length is determined by the position of the first null.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 \
7.	The Run-time package\
\
7.1	I/O Considerations\
\
	      All I/O operations in XPL require a unit number.  The runtime package has a table that maps unit number to FILE pointers.  The same table is used for both input and output except for unit zero.  The default unit numbers are:\
		Input unit 0 -> stdin		Output unit 0 -> stdout\
		Unit 1 -> stderr\
\
	All other unit numbers are undefined when the program starts up.  They may be assigned by using the builtin function 
\b xfopen
\b0 .\
\
	      I/O errors detected by the XPL runtime will set the variable 
\b xerrno
\b0  to the value of the errno variable which is normally set by the C runtime library.\
\
7.2	The Compactify Procedure\
\
	      COMPACTIFY is the procedure in the run-time package that garbage collects the free string area.  When an XPL program starts it calls MALLOC() to get space for the free string area.  The amount of space requested can be modified by declaring a macro for the identifier FREESPACE in the main body of the program.  The value should be an integer in a format acceptable to the C programming language.  The value is the number of bytes requested.  Example:\
\
		
\b declare FREESPACE literally '0x10000';
\b0 \
\
	      Once the free string area is allocated there is no ability to expand it.\
	      The COMPACTIFY procedure uses the variable, 
\b space_needed
\b0 , to determine how much space a particular operation will need to complete.  Some operations such as input default to 1024 bytes.  If COMPACTIFY cannot satisfy the amount of space needed then the program will abort with the following message printed on stderr:\
\
	
\b *** Notice from compactify(): Insufficient string space. Job abandoned. ***
\b0 \
\
	      The garbage collection process has two forms.  The first is a major collection where the entire string space is collected.  After a major collection the variable 
\b lower_bound
\b0  is set to the top if the free string area.  The second type of collection is where it only collects strings above the 
\b lower_bound
\b0 .  This is call a minor collection.  The hope is that the minor collections will free up enough space so that a major collection is not needed.\
	      When searching for strings to collect the COMPACTIFY procedure will ignore any descriptor that points to a string outside the free string area.  Fixed length strings are never garbage collected.\
\
8.	Limitations and Restrictions\
\
8.1	Limitations and missing features\
\
	      Using C as a target language enforces a number of restrictions on the XPL compiler.  Most of these are minor but I list them here so you can decide.  In the following text XPL69 refers to the original XPL implementation as described in \ul A Compiler Generator\ulnone .\
\
	1) When calling a function or subroutine you should supply all arguments defined by the procedure.  XPL69 allowed arguments to be omitted and they would retain values from the previous call.  Since the C compiler requires the number of arguments to match the XPL compiler adds arguments to fill out the procedure call.  These arguments are set to zero.  Forward reference procedures defined with the LABEL declaration will not have extra arguments appended because the compiler does know the number of arguments in the procedure.\
\
	2) Declare statements may only be used at the beginning of a block.  This exactly matches the restrictions in the C language as defined by K&R.  XPL69 allowed declarations to be anywhere.\
\
	3) Functions can not assume a default type.  The type of a function must be explicitly declared.\
\
	4) Return statements must match the declaration type of the procedure.  Functions must only use RETURN <expression> and subroutines must only use RETURN without <expression>\
\
	5) Formal parameters may not be arrays.  This restriction may be lifted in the future.  The implementation would pass only the value at index zero.\
\
	6) GOTO statements cannot enter or exit procedures.  I see this as an improvement.\
\
	7) XPL69 allows control to reach the end of a non-void function.  In the original compiler it returned a random value.  This XPL compiler will return zero.\
\
	8) String constants are stored in READ-ONLY memory.  Some C compilers have an option that will put the string constants in READ/WRITE memory.  The C compiler on a MAC will put the strings in READ/WRITE memory by using the -fwritable-strings option.\
\
	9) Some variables declared within a procedure may not retain their values after the procedure exits.  XPL69 made all variables 
\b static
\b0 .  This allowed their values to be retained across procedure calls.  This XPL compiler puts some variables on the stack which makes them lose their value when the procedure exits.\
\
	10) Variables that are not declared as arrays may not have a subscript.  XPL69 allowed all variables to be subscripted.  For example the following is illegal:\
		
\b declare a fixed, b(20) fixed;\
		a(3) = 2;   /* This is ILLEGAL */
\b0 \
\
	11) The order of variables in memory may not resemble XPL69.  The original XPL compiler used the order of declaration to simulate overlapping memory something similar to the UNION declaration in C.  The following is legal but probably won\'92t work:\
		
\b declare a(0) fixed, b(255) bit(8);\
		a(3) = 2;
\b0 \
\
	12) Macros are placed in the symbol table and have scope.  Macros defined within a procedure are undefined at the close of the procedure.  XPL69 put macros in a global table and they lasted until the end of the program even if they were defined within a procedure.\
\
Appendix A --- Compiler Options --- \
\
	Usage:\
	   xpl [-DGHIKLmMSTUWXY] [-v number] [-o outfile] [-s stringfile] file\
	      -o outfile - Output file name for C code\
	      -s stringfile - Output string header file name\
	      -v number - Number of entries reserved for the argv array\
	      file - XPL input source file name\
	\
	   Uppercase letters set initial values for compiler toggles\
	      D - Dump stats at the end of compilation\
	      G - Cross compile from a 64-bit machine to a 32-bit machine\
	      H - Hide identifiers from the C compiler\
	      I - Ignore case for keywords and builtin functions\
	      K - Emit Linemarkers for the C compiler\
	      L - List source\
	      m - Do not generate code for main()\
	      M - Minimal source listing; takes precedence over -L\
	      S - Dump symbol table at end of each procedure\
	      T - Trace compiler productions\
	      U - Give warning for unused variables\
	      W - Inhibit warnings for undeclared variables and procedures\
	      X - Show macro expansions\
	      Y - Give warning for high order truncation\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2148\fi-2150\ri0\pardirnatural\partightenfactor0
\cf2 	-v number	Set the number of entries reserved for the argv array in the compiled program.   32 is the default.  If your program needs more than 32 command line options you may use this option to expand the number of descriptors used in the argv array.  This option has no effect on the command line of the compiler itself.\
\
	-o outfile	Sets the name of the output file of the XPL compiler.  This file is then used as the C source file which is passed to the C compiler.  The default is the basename of the input file with a .c appended.\
\
	-s stringfile	Set the name of the C header file that will be used by the C compiler.  The default is the basename of the object file with a .xh extension.\
\
	file		Is the name of the XPL source file.  I suggest using .xpl as an extension.  If missing the compiler will read input from stdin.  When the source file name is missing the -o option is required.\
\
	Compiler Toggles may be set on the command line or embedded in PL/I style comments.\
\
	-D		Dump stats at the end of compilation.\
	-G		Use this option when cross compiling from a 64 bit machine to a 32 bit machine.  This option makes the compiler interpret BIT(64) as a character string instead of an integer.\
	-H		Hide identifiers from the C compiler.  If your program uses an identifier name that is a standard C function such as strlen() or memcpy() you can use this option to tell the XPL compiler to mangle the names so they do not conflict with default definitions in the C language.  When this toggle is used within a comment it only needs to be placed around the definition of the variable.  Example:\
				/* $H  Hide this variable from the C compiler */\
				declare strlen fixed;\
				/* $H  Turn off the control toggle */\
	-I		Ignore case.  This allows the use of uppercase letters for keywords and builtin functions.  Once this option is turned on it can not be turned off.\
	-K		Emit Linemarkers for the C compiler.  This tells the compiler to generate #line directives when emitting code that is passed to the C compiler.  This should help you find errors that show up when the C source is compiled but were not detected by the XPL compiler.\
	-L		List source.  Back in the day, programmers would use line printers to get listing of their programs.  The listings would be annotated with line numbers and procedure names and the like.  You can capture this listing by redirecting stdout to a file.\
	-m		The code will be generated without a main() procedure.  This will allow some other program written in a different language to call the XPL program.  When using this option all statements must be enclosed within a PROCEDURE. \
	-M		Minimal source listing.  List the source code without all the useful annotations.  This takes precedence over -L.\
	-S		Print a symbol table dump at the end of the program and the end of each procedure on stdout.\
	-T		Trace compiler productions.  This is useful for debugging the compiler to tell when a line of text is being created for output.  This is way too noisy to be generally useful.\
	-U		Give warnings for unused variables.\
	-W		Inhibit warnings for undeclared variables and procedures.\
	-X		Show macro expansion.  When a macro defined by the LITERALLY statement is expanded the compiler will show the expansion and print a line to stdout.\
	-Y		Give warning for high order truncation.  When this option is set a warning is printed when the program tries to store a large value into a smaller memory location.\
\
	Other dollar options that may be used in PL/I style comments.\
\
	$|		Margin chop.  This option may not be used on the command line because the position of the | is used to tell the compiler where to stop scanning text.  All text to the right of the vertical bar | is ignored.  This is used to sequence your card deck.\
\
	Using the C preprocessor\
 			The C preprocessor may be used to preprocess XPL source code.  The XPL compiler correctly handles the line markers generated by the C preprocessor.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 \
Appendix B --- Built-in Functions --- \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2150\fi-2152\ri0\pardirnatural\partightenfactor0
\cf2 	XPL_EOF	The variable 
\b xerrno
\b0  will be set to this value when the builtin function 
\b input
\b0 () reads an EOF from a file that was opened in binary mode.\
\
	__LINE__	A macro that expands to the current line number of the input text.\
\
	abort		A subroutine that will abort execution of the current program.\
\
	addr(v)	A builtin function that returns the address of the variable v.  The variable v may be subscripted if it is declared as an array.\
\
	address	A macro that expands to BIT(32) on 32-bit machines and expands to BIT(64) on 64-bit machines.  This is a transparent way to hold an address when porting between machines with different size addresses.\
\
	argc		A 32-bit integer that holds the number of elements in the 
\b argv
\b0  array.  Note:  This holds the number of elements exactly like the 
\b argc
\b0  variable in C.  It does not hold the number of elements minus one as is the standard practice in XPL.\
\
	argv(31)	A CHARACTER string array the holds the values of the options passed on the command line.  
\b argv(0)
\b0  holds the program name.  The maximum number of elements in the 
\b argv
\b0  array can be changed with the -v option at compile time.\
\
	build_descriptor(length, address)	Build a string descriptor with the 
\b length 
\b0 and 
\b address
\b0 .  The string need not be in the dynamic string space.  One of the uses of this function is to pull character strings out of buffers.  For example, let\'92s say you have an input record that is 256 bytes long and bytes 10 through 19 hold a username.  You can convert a portion of the buffer into a string by using build_descriptor().  Example:\
				
\b declare buffer(255) bit(8);\
				declare username character;\
				/* \'85 code that reads/creates the buffer \'85 */\
				username = build_descriptor(10, addr(buffer(10));\
				output = 'Username: ' || username;
\b0 \
\
	byte(string, position)	This is a builtin function that acts like a preudo-array which allows access to the string at the selected position.  The position starts counting at zero.  The byte function may appear on either the left or the right of the assignment operator.  The sequence:\
				
\b S = 'ABC';  I = byte(S, 1);
\b0 \
			Returns the value of 'B' ("42" in hex.  66 in decimal.).  The following is an example of 
\b byte()
\b0  used on the left of an assignment operator:\
				
\b S = 'ABC';  S = S || S;  byte(S, 2) = "41";
\b0 \
			The above sequence will assign the value of 'ABAABC' to S.  The 
\b byte()
\b0  function modifies the string but does not move it.  Any SUBSTRings pointing to the same area will also be modified.  The 
\b byte()
\b0  function can be used with both dynamic CHARACTER strings as well as fixed length strings.\
			When position is out of range the 
\b byte
\b0  function will return zero.\
				
\b x = byte(string, length(string));  /* x will always be zero */
\b0 \
\
	byte(string)	Short form of the above function which refers to the first element of the string.  This is equivalent to byte(string, 0).  This form of the byte() function is commonly used to convert string constants to integers.  For example:\
				
\b if byte(string, position) = byte(';') then do; /* process semicolon */ end;
\b0 \
\
	compactify	A subroutine used for garbage collection of the string area.  The casual user need never call it, but it is useful if you wish to control the exact point at which garbage collection is done.\
\
	corebyte(address)	A BIT(8) array that starts at location zero and allows access to the entire memory.  This array may be used on either side of the assignment operator.\
\
	corehalfword(address)	A BIT(16) array that starts at location zero and allows access to the entire memory.  This array may be used on either side of the assignment operator.\
\
	corelongword(address)	A BIT(64) array that starts at location zero and allows access to the entire memory.  This array may be used on either side of the assignment operator.\
\
	coreword(address)	A BIT(32) array that starts at location zero and allows access to the entire memory.  This array may be used on either side of the assignment operator.\
\
	date		A function that returns today\'92s date as a 32-bit integer in the format:\
				(year - 1900) * 1000 + day_of_year\
			January first is day one.  Jan 1, 2000 returns 100001.\
			The return value is computed from the C function 
\b localtime()
\b0 .\
\
	date_of_generation	A bit(32) variable the holds the value of the 
\b date
\b0  function when the code was compiled.\
\
	descriptor()	An array which holds all the descriptors used by the program.\
\
	exit		When used without an argument this function will abort the program.  This implementation is compatible with the XPL language specification.\
\
	exit(v)		When used with an argument this function will exit the program with the return code v.  This usage is compatible with the C language specification.\
\
	expand_tabs(string, tabstop)  A CHARACTER function that expands the tabs in the 
\b string
\b0  using 
\b tabstop
\b0  as the tab position.  The beginning of the string is used as the left margin.  This function returns the new string.\
\
	file(unit, position)	A builtin function that provides random access to the I/O device associated with unit.  The length of the operation is taken from the size of the array being read or written.  
\b position
\b0  is in multiples of the buffer size.  
\b position
\b0  starts at zero.  
\b file
\b0  is used like an assignment statement and the other side of the assignment statement is an array that is used to hold the data.  Example:\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li3603\fi-3606\ri0\pardirnatural\partightenfactor0
\cf2 				
\b declare buf(1023) bit(8), (unit, p) fixed;\
				p = 0;\
				buf = file(unit, p); 
\b0  /* Read 1024 bytes of record zero into the array buf */\
				
\b file(unit, p + 1) = buf;
\b0   /* Write the data back to the next record. */\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2150\fi-2152\ri0\pardirnatural\partightenfactor0
\cf2 			      The file function call may not be used on both the left and right of the assignment in the same statement.\
			      I hate this function.  Its original design used a record length that was hard coded in the runtime.  I have added an extension to the language to change the maximum record length by setting the 
\b file_record_size
\b0  variable.\
\
	file_record_size	A BIT(64) (or BIT(32)) variable that holds the maximum record size for the 
\b file
\b0  builtin function.  This may be used to read or write less than the buffer size used in the 
\b file
\b0  statement.  If set to zero this value is ignored.  XPL69 sets the record size in an assembly time constant when building the submonitor.  If you have an IBM 2311 disk set this value to 3600.  If you have an IBM 2314 disk set this value to 7200.\
\
	freebase	A BIT(64) (or BIT(32)) variable that points to the byte address of the start of the free string area.  Don\'92t play with it.\
\
	freelimit	A BIT(64) (or BIT(32)) variable that points to the byte address of the end of the free string area.  Don\'92t play with this one either.\
\
	freepoint	A BIT(64) (or BIT(32)) variable that points to the byte address of the next available byte of the free string area.  When 
\b freepoint
\b0  exceeds 
\b freelimit
\b0  the 
\b compactify
\b0  procedure is automatically called to compress the free string area.  Just so long as you don\'92t go mucking about with my pointers.\
\
	hex(value)	This builtin function returns the hexadecimal equivalent of the 
\b value
\b0  as a character string.\
\
	inline(string, \'85)	This builtin function will insert a string into the C code being generated by the compiler.  Examples:\
				
\b call inline('#define MAXNAME 7');\
				call inline('extern char * user_string;');
\b0 \
			Note that the semicolon is not supplied by the compiler.  The above statements will generate the following code.\
\
			
\b #define MAXNAME 7\
				extern char * user_string;
\b0 \
\
			      If inline is called with multiple arguments the strings will be concatenated and placed on the same line.  For example:\
				
\b call inline('int stuff;', 'stuff = 6;');
\b0 \
			Will generate the following code:\
				
\b int stuff;stuff = 6;
\b0 \
\
			The XPL compiler will sometimes mangle names when translating to C code.  The inline function can access these names by placing the identifier as an argument without quotes.  Example:\
				
\b abc: procedure(xyz);\
					call inline(xyz, ' = some_function();');\
				end abc;
\b0 \
			Generates the code:\
				
\b void abc(__xpl_1) \{\
					__xpl_2_xyz = some_function();\
				\}
\b0 \
\
 			      Inline may also be used as a function on either the left or the right of the assignment operator.  Example:\
\
				
\b inline('special_value') = inline('i ^ 7');
\b0 \
\
			      The above statement will generate the following code:\
\
				
\b special_value = i ^ 7;
\b0 \
\
	\
			     The inline function may be used to access C header files.  The following code will access the socket library from XPL code.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li3624\fi-3627\ri0\pardirnatural\partightenfactor0
\cf2 				
\b call inline('#include <sys/socket.h>');\
				call inline('#include <netinet/in.h>');\
				call inline('struct sockaddr_in server;');\
\
				declare PF_INET literally 'inline(''PF_INET'')';\
				declare PF_INET6 literally 'inline(''PF_INET6'')';\
\
				declare SOCK_STREAM literally 'inline(''SOCK_STREAM'')';\
				declare SOCK_DGRAM literally 'inline(''SOCK_DGRAM'')';\
				declare SOCK_RAW literally 'inline(''SOCK_RAW'')';\
\
				inline('server.sin_family') = AF_INET;
\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2150\fi-2152\ri0\pardirnatural\partightenfactor0
\cf2 \
			    The inline function may be used to insert or remove casts from a statement as is done by this example:\
\
				
\b call inline('#include <string.h>');\
\
				strchr: procedure(s, c) address transparent;\
				       declare s address, c fixed;\
				   end strchr;\
\
				declare result address;\
				declare string character(80);\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li3584\fi-3587\ri0\pardirnatural\partightenfactor0
\cf2 				result = inline('(XPL_ADDRESS)', strchr(inline(string), byte('?')));
\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2150\fi-2152\ri0\pardirnatural\partightenfactor0
\cf2 \
			    The 
\b strchr()
\b0  call generates the following line:\
				
\b result = (XPL_ADDRESS)strchr(string, 63);
\b0 \
\
	input(unit)	A CHARACTER function that reads one record from the specified 
\b unit
\b0 .  Unit zero defaults to 
\b stdin
\b0 .  Example:\
\
				
\b declare text character;\
				text = input(2);
\b0 	/* Read one string from unit 2 */\
\
			The 
\b input
\b0  function reads characters up to a new-line indicator (LineFeed on UNIX, CarriageReturn/LineFeed on MS-DOS).  The new-line indicator is discarded and the remaining text is returned.  End-of-file is indicated by returning a zero-length string.  Lines that would otherwise be of length zero (after trimming) will be padded with one blank to distinguish them from End-of-file.\
\
			If you open a file in binary mode it will return all characters in the input stream.  Reading a binary file will typically return a string of 1024 bytes.  An End-of-file will be indicated by returning a null string.  See 
\b xfopen
\b0  for a description of how to open a file in binary mode.\
\
			Both versions of the 
\b input
\b0  function will set 
\b xerrno
\b0  to 
\b XPL_EOF
\b0  to indicate an End-of-file.\
\
	input		Same as 
\b input(0)
\b0 \
\
	input_record_limit	A BIT(32) variable that holds the maximum record size returned by the 
\b input
\b0  builtin function.  This is useful for reading records that are not terminated with a newline character.  The default is 1024.\
\
	length(string)	A function that will return the length of a character string.  See also 
\b saddr()
\b0 .\
\
	ndescript	A BIT(32) variable the holds the number of descriptors minus one.  This value should never be changed.\
\
	output(unit)	A CHARACTER pseudo-variable that has the effect of writing a string to the specified 
\b unit
\b0 .  Unit zero is 
\b stdout
\b0 .  Unit one is 
\b stderr
\b0 .  A newline is appended to each output line unless the output is opened as a binary device with 
\b xfopen
\b0 .  Examples:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li3596\fi-3599\ri0\pardirnatural\partightenfactor0

\b \cf2 				output(0) = 'Hello World!';
\b0 	/* You were expecting this.  Right? */\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2150\fi-2152\ri0\pardirnatural\partightenfactor0
\cf2 				
\b output(1) = 'Major error detected.';
\b0 \
\
			I have chosen to follow the C convention rather than the XPL69 standard.  Seriously, when was the last time you had a line printer connected to your computer?\
\
	output		Same as 
\b output(0)
\b0 .\
\
	saddr(string)	This function returns the address portion of the string descriptor.  If the string is in the dynamic string area the 
\b compactly
\b0  procedure \ul might\ulnone  move the string causing the results of the 
\b saddr()
\b0  function to be invalid.  As a result the address has a very limited lifespan.  The address returned by a null string may contain garbage.  You should check for length equals zero before using this function.\
\
	shl(value, count)	A logical left shift of the 
\b value
\b0 , 
\b count
\b0  bits.  Left shifting a constant a constant number of bits is done at maximum precision within the XPL compiler.  The behavior of this function when doing type conversions and handling weird shift counts is left up to the underlying C compiler.  Example:\
				
\b j = 2;\
				k = shl(j, 2); 
\b0  /* k will be set to 8 */\
\
	shr(value, count)	A logical right shift of the 
\b value
\b0 , 
\b count
\b0  bits.  This shift does a zero fill on the most significant bits of 
\b value
\b0 .  Right shifting a constant a constant number of bits is done at maximum precision within the XPL compiler.  The behavior of this function when doing type conversions and handling weird shift counts is left up to the underlying C compiler.  Example:\

\b 				j = 8;\
				k = shr(j, 2); 
\b0  /* k will be set to 2 */\
\
			Right shifting negative constants will probably give you an unexpected result.\
\
	substr(string, start, length)	This CHARACTER function permits the dissection of strings.  The 
\b start
\b0  is character position counting from zero.  The 
\b length
\b0  will be the number of characters in the resultant string.  This function will not create a new string that lies outside the original string.  If 
\b start
\b0  is larger than the length of the original string this function will return a null string.  Only a new descriptor is created.  The data in the string is not moved.  This function may only be used on the right hand side of the assignment operator.\
\
	substr(string, start)	This form of the 
\b substr
\b0  function returns the balance of the string starting at position 
\b start
\b0 .  It is shorthand for:\
\
				
\b substr(string, start, length(string) - start)
\b0 \
\
			This function may only be used on the right hand side of the assignment operator.\
			Only a new descriptor is created.  The data in the string is not moved.\
\
	time		A BIT(32) function that returns the time-of-day in centiseconds since midnight.  The return value is computed from the C function 
\b localtime()
\b0 .\
\
	time_of_generation	A BIT(32) variable with value of 
\b time
\b0  when the program was compiled.\
\
	trace		This subroutine does nothing.  It is included here for compatibility. \
\
	unique(string)	A CHARACTER function that moves the string to the top of the free string area and returns a new descriptor.  The function guarantees that the string has only one descriptor pointing to it.  Modifying this string with the 
\b byte()
\b0  function will have no side effects.  The original XCOM compiler uses 
\b SUBSTR(' ' || ' ', 1)
\b0  to generate a unique string.  This will not work with this compiler.  This compiler will concatenate the two constant strings creating one string of two bytes.  The following code does work on this compiler and has the same result as the 
\b unique()
\b0  function:\
\
				
\b string = ' ';\
				unique_string = substr(string || string, 1);
\b0 \
\
	untrace	This subroutine does nothing.  It is included here for compatibility.\
\
	xerrno		A BIT(32) variable that is used to indicate errors in the XPL runtime.  The 
\b xerrno
\b0  variable will be set to 
\b EBADF
\b0  if the unit is out of range and will be set to 
\b XPL_EOF
\b0  on EOF.  The 
\b xerrno
\b0  variable will be set to the value of the C variable 
\b errno
\b0  if the C runtime library reports an error in the I/O operation.  Unlike the C variable 
\b errno
\b0  the value of 
\b xerrno
\b0  will be cleared if the I/O operation is successful.\
\
	xfclose(unit)	A subroutine that interfaces to the C 
\b fclose()
\b0  function.	 The 
\b unit
\b0  number should be a number returned by 
\b xfopen
\b0 .\
\
	xfdopen(fd, mode)  A function that interfaces to 
\b fdopen()
\b0  in the C library.  This function returns a 
\b unit
\b0  number if successful and returns -1 if there was an error.  The file descriptor 
\b fd
\b0  must be a valid file descriptor for an open file.  The 
\b mode
\b0  is a CHARACTER string that holds one of the values described by the 
\b xfopen
\b0  procedure call.  See 
\b xfopen
\b0 .\
\
	xfopen(filename, mode)	A function that interfaces to the C 
\b fopen()
\b0  function.  This function returns a 
\b unit
\b0  number if successful and returns -1 if there was an error.  The 
\b filename
\b0  is an XPL CHARACTER string that holds the name of the file to be opened.  The 
\b mode
\b0  is one of the following:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2873\fi-2876\ri0\pardirnatural\partightenfactor0
\cf2 			'r'	Open text file for reading.  The stream is positioned at the beginning of the file.\
\
			'r+'	Open for reading and writing.  The stream is positioned at the beginning of the file.\
\
			'w'	Truncate to zero length or create text file for writing.  The stream is positioned at the beginning of the file.\
\
			'w+'	Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The stream is positioned at the beginning of the file.\
\
			'a'	Open for writing.  The file is created if it does not exist.  The stream is positioned at the end of the file.  Subsequent writes to the file will always end up at the then current end of file, irrespective of any intervening fseek(3) or similar.\
\
			'a+'	Open for reading and writing.  The file is created if it does not exist.  The stream is positioned at the end of the file.  Subsequent writes to the file will always end up at the then current end of file, irrespective of any intervening fseek(3) or similar.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2150\fi-2152\ri0\pardirnatural\partightenfactor0
\cf2 \
			The 
\b mode
\b0  can also include the letter 'b'.  This will cause the 
\b input
\b0  function to return the data exactly as read from the device and the 
\b output
\b0  function will not append a newline.\
\
			A successful open will allow both reads and writes to the 
\b unit
\b0 .  It is up to the programmer to prevent reads from write only devices and writes to read only devices.\
\
			Example:\
\
			
\b unit = xfopen('/tmp/sourcefile', 'w');\
			if unit < 0 then do;\
				output(1) = 'File open error.  Program aborted.';\
				call exit(1);\
			end;\
\

\b0 	xfprintf(unit, format, args, \'85)	A print function that works similar to the 
\b fprintf()
\b0  function in the C programming language.  This function returns the number of characters printed.  The 
\b unit
\b0  may be opened with the 
\b xfopen
\b0  function call.  Example:\
\
			
\b declare age fixed initial(4);\
\
			call xfprintf(unit, "(c) I am %d years old today.\\n", age);\

\b0 \
			See Appendix D for a description of the format string.\
\
	xio_get_flags(unit)    Return the I/O flags for the specified 
\b unit
\b0 .  The current implementation only defines one flag bit.\
			0 -> Normal I/O conforming to the original XPL specification.\
			1 -> Binary I/O.  Input is raw data.  Output does not get a newline appended.\
			    If the 
\b unit
\b0  is out of range the function returns -1 and 
\b xerrno
\b0  is set to EBADF.\
\
	xio_set_flags(unit, value)    Set the I/O flags for the specified 
\b unit
\b0 .  If 
\b unit
\b0  is out of range the function returns -1 and sets 
\b xerrno
\b0  to EBADF.  The 
\b value
\b0  is a BIT(32) variable.  See 
\b xio_get_flags
\b0  for a definition of the flag bits.\
\
	xmkstemp(filename, mode)     Make a temporary file.  This function will call 
\b mkstemp()
\b0  from the C library.  When the 
\b xmkstemp
\b0  function is called the filename is a template that usually has six 'X's in the template.  The 
\b xmkstemp
\b0  call will modify the template to create a unique filename.  The filename is returned in the first argument.  Files created by 
\b xmkstemp
\b0  are not automatically deleted on close.  You will probably want to remove these file by calling 
\b xunlink
\b0 .  Example:\
\
			
\b declare filename character;\
			declare unit fixed;\
\
			filename = '/tmp/zXXXXXX';\
			unit = xmkstemp(filename, \'91r+\'92);\
			if unit < 0 then do;\
				output(1) = 'Error ' || xerrno || ' creating temporary file: ' || filename;\
				call exit(4);\
			end;\
			output(unit) = 'Stuff written to the temporary file';\
			/* Delete the file when you are done */\
			call xfclose(unit);\
			call xunlink(filename);
\b0 \
\
			The mode argument is the same as the mode argument in the 
\b xfopen
\b0  call.  However only \'91r+\'92 and \'91r+b' are useful.\
\
	xprintf(format, args, \'85)	A print function that works similar to the 
\b printf()
\b0  function in the C programming language.  The output is sent to unit zero.  This function returns the number of characters printed.  Example:\
\
			
\b declare age fixed initial(4);\
\
			call xprintf("(c) I am %d years old today.\\n", age);\

\b0 \
			See Appendix D for a description of the format string.\
\
	xrewind(unit)    Rewind an I/O stream.  This function will position the file back to the beginning.  Example:\
\
			
\b declare filename character initial('foo.txt');\
			declare text character;\
			declare (unit, code) fixed;\
\
			unit = xfopen(filename, 'w+');\
			if unit < 0 then do;\
				output(1) = 'File open error: ' || filename;\
				call exit(1);\
			end;\
			output(unit) = 'This text is at position zero.';\
			/* Write more text here */\
			code = xrewind(unit);\
			if code < 0 then do;\
				output(1) = 'Rewind failed.';\
				call exit(2);\
			end;\
			/* The next read will get the first record */\
			text = input(unit);
\b0 \
\
	xsprintf(buffer, format, args, \'85)	A character conversion function that works similar to the 
\b sprintf()
\b0  function in the C programming language.  The buffer may be a dynamic string or a fixed length string.  The buffer may not be an expression.  This function returns the number of characters put into the buffer.  Example:\
\
			
\b declare age fixed initial(4);\
			declare string character;\
			declare text character(80);\
\
			call xsprintf(string, 'Help me %s.  You''re my only hope.', \
				'Obi Wan');\
			call xsprintf(text, 'string="%s", age=%3.2d', string, age);\
\
			/* The buffer is cleared at the beginning of the function call.  */\

\b0 \
			See Appendix D for a description of the format string.\
\
	xunlink(filename)    Delete a file.  This function calls the 
\b unlink()
\b0  function from the C library.  
\b xerrno
\b0  is set if there is an error.  Example:\
\
			
\b declare filename character;\
			declare error_code fixed;\
\
			filename = 'myfile.tmp';\
			error_code = xunlink(filename);\
			if error_code < 0 then do;\
				output = 'Error ' || xerrno || ' deleting: ' || filename;\
			end;
\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 \
\
\
Appendix C \'97 Name space pollution\
\
	    This XPL compiler suffers from name space pollution because it must deal with both XPL identifiers and the special purpose identifiers defined by the underlying C compiler.  The XPL compiler mangles identifiers and PROCEDURE names to minimize the impact of name conflicts.  In the event that a local variable does cause a name conflict the -H option (or the $H flag) may be set to tell the compiler to mangle all identifier names.  However the -H option has no useful effect on PROCEDURES that are declared EXTERNAL.  Identifiers used in the XPL runtime may not be used as EXTERNAL PROCEDURES.  All reserved words in the C language are not permitted as EXTERNAL PROCEDURE names.  Identifiers promoted to global scope are not permitted as EXTERNAL PROCEDURES.  Identifiers that start with __XPL and __xpl are reserved for the compiler.\
\
	    The -D option will display the table of \'93Identifiers promoted to Global Scope\'94 and the table of \'93Identifier mapper definitions\'94 at the end of compilation.  The identifiers promoted to global scope depend on the identifiers used in nested PROCEDURES.\
\

\f1\b 	Identifiers that may not be used as external procedures:\
\
	argc\
	argv\
	compactify\
	corebyte\
	corehalfword\
	corelongword\
	coreword\
	descriptor\
	file_record_size\
	freebase\
	freelimit\
	freepoint\
	ndescript\
\
\
	Identifiers promoted to Global Scope:\
\
	
\f0\b0 /* nested procedures will be listed here */
\f1\b \
\
	Identifier mapper definitions:\
\
	for                  literally: __xpl_for\
	int                  literally: __xpl_int\
	auto                 literally: __xpl_auto\
	char                 literally: __xpl_char\
	enum                 literally: __xpl_enum\
	long                 literally: __xpl_long\
	void                 literally: __xpl_void\
	main                 literally: __xpl_main\
	exit                 literally: __xpl_exit\
	break                literally: __xpl_break\
	const                literally: __xpl_const\
	float                literally: __xpl_float\
	short                literally: __xpl_short\
	union                literally: __xpl_union\
	_Bool                literally: __xpl__Bool\
	index                literally: __xpl_index\
	abort                literally: __xpl_abort\
	double               literally: __xpl_double\
	extern               literally: __xpl_extern\
	signed               literally: __xpl_signed\
	sizeof               literally: __xpl_sizeof\
	static               literally: __xpl_static\
	struct               literally: __xpl_struct\
	switch               literally: __xpl_switch\
	inline               literally: __xpl_inline\
	size_t               literally: __xpl_size_t\
	typeof               literally: __xpl_typeof\
	default              literally: __xpl_default\
	typedef              literally: __xpl_typedef\
	_Atomic              literally: __xpl__Atomic\
	continue             literally: __xpl_continue\
	register             literally: __xpl_register\
	unsigned             literally: __xpl_unsigned\
	volatile             literally: __xpl_volatile\
	_Complex             literally: __xpl__Complex\
	restrict             literally: __xpl_restrict\
	_Alignas             literally: __xpl__Alignas\
	_Alignof             literally: __xpl__Alignof\
	_Generic             literally: __xpl__Generic\
	_Noreturn            literally: __xpl__Noreturn\
	_Imaginary           literally: __xpl__Imaginary\
	_Thread_local        literally: __xpl__Thread_local\
	_Static_assert       literally: __xpl__Static_assert
\f0\b0 \
\
	TRANSPARENT PROCEDURES are not affected by this problem because the desired result is to use the C library function.\
\
\
Appendix D --- Format strings ---\
\
	The functions xfprintf, xprintf, and xsprintf all use the same format strings.  The general form of a format string is:\
\
		%[flags][width][.precision][length]specifier\
\
	The following flags are supported:\
\
	+	Positive signed integers should be proceeded by a plus sign.\
	-	Left justify\
	<sp>	Space.  Numbers should be proceeded by a space.  Ignored if + is used.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li1422\fi-1424\ri0\pardirnatural\partightenfactor0
\cf2 	#	Prefix octal, hex (lower case) and hex (upper case) with 0, 0x and 0X respectively.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 	0	Zero fill.  Ignored if left justify.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2150\fi-2152\ri0\pardirnatural\partightenfactor0
\cf2 	width		Is the field width.  This is a decimal number or a *.  If a * then the next argument is used as the width.  The argument should be a BIT(32) value.  If the width is smaller than the converted string value then the width is ignored.\
\
	precision	For integer values this is the minimum number of digits to be printed.  For strings this is the maximum length of the string.  This field may be a decimal number or a *.  If a * then the next argument is used as the precision.  The argument should be a BIT(32) value.\
\
	length		One of the following:\
\
			h - BIT(16)\
			hh - BIT(8)\
			l, ll, j, z, t, L - BIT(32) or BIT(64) depending on your hardware.\
\
			If the length is missing the function will assume BIT(32).\
\
	specifier	One of the following:\
\
			%	Print %\
			d, i	Integer\
			u	Unsigned integer\
			o	Octal\
			x	Hexadecimal with lower case letters\
			X	Hexadecimal with upper case letters\
			s	Character string\
			p	Address as returned by the ADDR() function\
			c	A single character\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li2882\fi-2885\ri0\pardirnatural\partightenfactor0
\cf2 			n	Returns the number of characters written so far.  The argument must be an address that points to a BIT(32) integer.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li721\fi-722\ri0\pardirnatural\partightenfactor0
\cf2 \
Appendix E --- BNF ---\

\f1\b \
	<program> ::= <statement list>\
	<statement list> ::= <statement>\
	                 | <statement list> <statement>\
	<statement> ::= <basic statement>\
	            | <if statement>\
	<basic statement> ::= <assignment> ;\
	                  | <group> ;\
	                  | <procedure definition> ;\
	                  | <return statement> ;\
	                  | <call statement> ;\
	                  | <go to statement> ;\
	                  | <declaration statement> ;\
	                  | ;\
	                  | <label definition> <basic statement>\
	<if statement> ::= <if clause> <statement>\
	               | <if clause> <true part> <statement>\
	               | <label definition> <if statement>\
	<if clause> ::= if <expression> then\
	<true part> ::= <basic statement> else\
	<group> ::= <group head> <ending>\
	<group head> ::= do ;\
	             | do <step definition> ;\
	             | do <while clause> ;\
	             | do <case selector> ;\
	             | <group head> <statement>\
	
\fs22 <step definition> ::= <variable> <replace> <expression> <iteration control>
\fs24 \
	<iteration control> ::= to <expression>\
	                    | to <expression> by <expression>\
	<while clause> ::= while <expression>\
	<case selector> ::= case <expression>\
	<procedure definition> ::= <procedure statement> <statement list> <ending>\
	<procedure statement> ::= <procedure head> ;\
	                      | <procedure head> external\
	                      | <procedure head> transparent\
	<procedure head> ::= <procedure name>\
	                 | <procedure name> <type>\
	                 | <procedure name> <parameter list>\
	                 | <procedure name> <parameter list> <type>\
	<procedure name> ::= <label definition> procedure\
	<parameter list> ::= <parameter head> <identifier> )\
	<parameter head> ::= (\
	                 | <parameter head> <identifier> ,\
	<ending> ::= end\
	         | end <identifier>\
	         | <label definition> <ending>\
	<label definition> ::= <identifier> :\
	<return statement> ::= return\
	                   | return <expression>\
	<call statement> ::= call <variable>\
	<go to statement> ::= <go to> <identifier>\
	<go to> ::= go to\
	        | goto\
	<declaration statement> ::= declare <declaration element>\
	        | <declaration statement> , <declaration element>\
	<declaration element> ::= <type declaration>\
	                      | <identifier> literally <string>\
	<type declaration> ::= <identifier specification> <type>\
	                   | <bound head> <expression> ) <type>\
	                   | <type declaration> <initial list>\
	<type> ::= fixed\
	       | character\
	       | label\
	       | <bit head> <expression> )\
	       | <character head> <expression> )\
	<bit head> ::= bit (\
	<character head> ::= character (\
	<bound head> ::= <identifier specification> (\
	<identifier specification> ::= <identifier>\
	                  | <identifier list> <identifier> )\
	<identifier list> ::= (\
	                  | <identifier list> <identifier> ,\
	<initial list> ::= <initial head> <expression> )\
	<initial head> ::= initial (\
	               | <initial head> <expression> ,\
	<assignment> ::= <variable> <replace> <expression>\
	             | <left part> <assignment>\
	<replace> ::= =\
	<left part> ::= <variable> ,\
	<expression> ::= <logical factor>\
	             | <expression> | <logical factor>\
	             | <expression> xor <logical factor>\
	<logical factor> ::= <logical secondary>\
	         | <logical factor> & <logical secondary>\
	<logical secondary> ::= <logical primary>\
	                    | ~ <logical primary>\
	<logical primary> ::= <string expression>\
	     | <string expression> <relation> <string expression>\
	<relation> ::= =\
	           | <\
	           | >\
	           | ~ =\
	           | ~ <\
	           | ~ >\
	           | < =\
	           | > =\
	<string expression> ::= <arithmetic expression>\
	           | <string expression> || <arithmetic expression>\
	<arithmetic expression> ::= <term>\
	                        | <arithmetic expression> + <term>\
	                        | <arithmetic expression> - <term>\
	                        | + <term>\
	                        | - <term>\
	<term> ::= <primary>\
	       | <term> * <primary>\
	       | <term> / <primary>\
	       | <term> mod <primary>\
	<primary> ::= <constant>\
	          | <variable>\
	          | ( <expression> )\
	<variable> ::= <identifier>\
	           | <subscript head> <expression> )\
	<subscript head> ::= <identifier> (\
	                 | <subscript head> <expression> ,\
	<constant> ::= <string>\
	<constant> ::= <number>\

\f0\b0 \
}